İngilizcelerini daha sonra hallederiz ;)

* <% Server tagleri directive anlamına gelir. Serverda çalıştırılacak C# kodları bu tagler arasına yazılır. <%@ directive yazmamızı sağlar o sağyfaya özel temel özellikleri veririz. <%: string kütüphanelerini(Response.Write("") ile aynı işi yapar), <% veri tabanı ile ilgili kütüphanelerini yükler. 

* runat="server" attribute ile işaretlenen control artık server tarafından ulaşılabilir olur. Örneğin <div runat="server" /> HtmlGenericControl olarak döndürür.

* MasterPage içinde değişmesini istediğin yere ContentPlaceHolder atıp MasterPageden türettiğin sayfaya Content atarak PlaceHolderId MasterPagedeki ContentPlaceHolderId yi vererek kullanabilirsin.
* MasterPageden türetilen ayrı  bir MasterPage NestedMasterPage olarak çalışabilirsin. Bulunmasını istemediğin bölümleri çıkarabilirsin.

* Repeater içinde button atmak işe yaramaz. Attığın bir LinkButton benzeri bir control ItemDataBound event içinde, eklediğin control için Repeater.ItemCommand eventi tetiklenir. Arayüzde CommandName attribute verdiğin string işlem ismine göre buton vb. yapacağı işi kontrol ederek Repeater.Control.Find() ile yakalayıp ItemCommand event içinde dönen tipe cast ederek ulaşırsan işe yarar. ItemCommand event içinde gelen EventArg propertylerine göre yapacağın işi belirleyebilirsin. ItemDataBound(s,e) içinde e.Item.DataItem seçilen satırı döndürür. Kendi class ına cast ederek kullanabilirsin. Bu event satır rengi değişimleri gibi işlemler için de kullanılabilir. Repeater sadece göstermek ve dışardan değer gerektirmeyen işlemlerde kullanılabilir. Dışardan ProductName update gibi bir işlem yapılacaksa Datalist veya GridView kullanılmalıdır. ItemCommand, ItemDataBound, e.Item.ItemType...

* e.Item.DataItem Repeater.ItemDataBound dışında her zaman null gelir. Sadece ItemDataBound event içinde DataItem yakalayıp istediğin class cast edebilirsin.s

* Her control HTML karşılığı vardır. HyperLink, LinkButton => <a>,Button => <input type="submit"> , Label => <span>, Panel => <div> gibi. Button gibi bir control atıp event doldurduğunda
<script src="/WebResource.axd?d=pynGkm2&amp;t=636995447080000000" type="text/javascript"></script> gibi sayfada unique bir script oluşturularak bu script üzerinden eventler çalıştırılır. 
bunu LinkButton eventi içinde kod çalıştırırken, HyperLink NavigateURL attribute ise sadece bir url'e gönderir. LinkButton benzeri control event ise sayfadaki __doPostBack(eventTarget, eventArgument) fonksiyonunu çalıştırarak işini yapar.

* ~ işareti çalıştırıldığı sayfadan root a çıkmayı sağlar. Aksi taktirde örneğin /Products/ klasör içinde <a href="Default.aspx" > yazılırsa http://www.localhost/Products/Default.aspx e gider fakat ~ konursa direk http://www.localhost/Default.aspx açar. Sadece runat="server" ile işaretlenmiş control de işe yarar.

* UserControl sayfaya register edebilmek için design görünümünde olmak gerekir.

* Repeater ile Datalist farkı, repeater direk verileri basarken DataList tablo olarak basar. Yine Datalist avantajı veriyi düzenleme moduna geçebilmesi. EditItemTemplate barındırır.

* Birden fazla değer taşıyacaksak HiddenField içinde tutmak mantıklı.

* ViewState nesnesi ile QueryString arasındaki fark: QueryString ile farklı sayfalar arasında veri taşıyabiliriz. ViewState ise farklı bir sayfaya geçildiğinde silinir, sadece o sayfa için geçerlidir.

* MemberShip için Tools > Command Line > Developer Command Prompt > aspnet_rgsql ile db tabloları insert ediyoruz. aspnet_regsql -? ile verilecek parametreleri görebiliriz. 
Web.config >system.web> içine C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\machine.config içinde <membership> tag seçip yapıştırıyoruz. Giriş-çıkış kontrolleri için LoginStatus kullanbilirsin.
DataCache için yine aynı aspnet_regsql keyword kullanılır. Örneğin Northwind için cache enable çekme komutu aspnet_regsql -S .\sqlexpress -d Northwind -U sa -P 123 -ed yazılırak önce cache enable çekilir. Daha sonra -t Products -et ile tablo için trigger eklenir. 

* Her klasörün kendi  web.config dosyası olabilir. Klasör içindeki web.cofigde <roleManager> tag ile içinde bulunduğu klasörün izinleri ayarlanabilir. örnegin Admin klasörü içinde <allow role="Admin"/> vermişsek <deny users="*"/> ile diğer kullancılıarın bu klasöre girişini kapatmak gerekir. örnegin Users klasörü için de <deny users="?"/> giriş yapan kullanıcılara izin verir diğer tümünü engeller. Sayfa basında girmesini istediğin kullanıcılar ya da roller için

<location path="PrivatePage.aspx">
    <system.web>
      <authorization>
        <allow roles="Sucker"/>
        <deny users="*"/>
      </authorization>
    </system.web>
  </location>

 benzeri bir yapı kurabilirsin. Sayfa içinde farklı içerik göstermek için LoginView componentinin <AnonymousTemplate>, <LoggedInTemplate> ve <RoleGroups><asp:RoleGroup Roles="Admin"><ContentTemplate>Welcome Admin</asp:RoleGroup> templatelerini kullanabilirsin.

 /************************ ASPNET MVC **************************/

 * Controllers ve View zorunludur. Models başka bir projeden de çekilebilir. Models içindeki classlar veri tabanı tablolarını temsil eder. Content klasörü dışardan eklenen dosyalardır. App_Start projenin başlangıcı ile ilgili metodların bulunduğu class lar bulunur. Script dosyaları Scripts klasöünde bulunur.

* Controller içindeki geriye ActionResult döndüren her metod için View klasöründe Controller ismi ile başlayan içinde metodun adı ile aynı Index.cshtml, ör:Home/Index.cshtml dosyası bulunur.

* @RenderBody() Layout sayfasında ana dekiği açar ve bu yüzden sadece bir kez bulunabilir. Farklı bir delik açmak için @RenderSection("head"), @RenderSection("script",required:false) gibi açılır.  Layoutda isimlendirelien delik 

@section scripts{

} şeklinde kullanılır.

* @ Razor Engine bir satırdan fazla yazmak için @{ } scope kullanılır. @* *@ yorum satırıdır.

* Önce Controller eklenir. Action yazılıp Action içinde sağ tıklayıp Add View denerek View ismi verilir.

* Controllerdan View a birkaç yöntem ile veri gönderilebilir.
 
 1-Model yöntemi ile göndermek: View(object model); View metodundan çekilen herhangi bir object model olarak döndürülür. View tarafında dönen bu object verinin asıl doğru tipini belirtmek için directive dışında @model [VeriTipi] olarak yakalanır. Ör: @model List<Product>. Ulaşılamayan class için @using keyword ile namespace eklenmelidir. View tarafında kullanmak için nesne Model propertysi ile çekilir. Yalnız bu yöntem sadece tek bir tip geldiğinde kullanılır. Bunu aşmak için Producties, Categoires gibi birden falza tipte propertyler barındıran ayrı bir class oluşturulabilir. 

 2-ViewBag yöntemi ile göndermek: ViewBag dynamic tiptir. İçine verilen herhangi bir tipi direk View tarafına taşır. ViewBag.AnyThings gibi vverdiğimiz bir Anonymus Type ya da belli bir tipi view tarafında yine aynı isimle yakalarız.

* Yazdığımız herhangi bir ActionResult default [HttpGet] ile işaretlenmiş olduğu için direk http get olarak çalışır. Örneğin ürün eklenecek bir sayfa için Product{controller}/Add{view} yazmış olalım. Öncelikle ürününekleneceği componentlerin olduğu sayfayı kullanıcıya göstermek için bir [HttpGet]ActionResult Add() yazılarak kategori, tedairkçi gibi listeler de çekilirek bu viewa döndürülür(çünkü ui için bunlara ihtyiaç var). Daha sonra componentlerden toplanan değerler post ile gönderilebilmesi için [HttpPost]ActionResult Add(Product p) metodu yazılır. View dan değerleri yakalayabilmek için de Product class içindeki property isimleri birebir aynıları view tarafındaki component name olarak verilir. Yani örneğin ürün ismi alacağımız textbox name="ProductName" olarak girmek zorunludur. Yazdığımız bu post ActionResult ekleme işini yaptıktan sonra return View() ile dönersek arayüzde ihtiyaç duyduğu category, supplier gibi listelere ihtyiaç duyacağı için patlayacaktır. Bu yüzden RedirectToAction("Index") gibi eklenen ürünü görmnek için listeleme yaptıuğımız ActionResult'a yönlendirmek gerekir. Eğer göndereceğimiz ActionReult başka bir controller içinde ise RedirectToAction() 2.parametresinde bu isim girilir.